<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Metroidvania - Combat Overhaul</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: white; pointer-events: none;
            text-shadow: 2px 2px 2px #000;
            z-index: 10;
        }

        #tutorial-overlay {
            position: absolute;
            top: 20px; right: 20px;
            display: flex; gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px; border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            pointer-events: none;
            z-index: 10;
        }

        .key-box { display: flex; flex-direction: column; align-items: center; gap: 5px; min-width: 45px; }
        .key { width: 35px; height: 35px; border: 2px solid #fff; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; transition: all 0.1s; }
        .key.active { background: #00d4ff; color: #000; transform: scale(0.9); box-shadow: 0 0 15px #00d4ff; }
        .key-label { font-size: 9px; text-transform: uppercase; color: #aaa; }

        #hp-bar-container { margin-top: 10px; }
        #hp-bar { width: 250px; height: 14px; background: rgba(255,255,255,0.1); border-radius: 7px; border: 1px solid rgba(255,255,255,0.3); overflow: hidden; position: relative; }
        #hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff4d4d, #ff0000); transition: width 0.3s; box-shadow: 0 0 10px #ff4d4d; }
        #hp-text { position: absolute; width: 100%; text-align: center; font-size: 10px; line-height: 14px; font-weight: bold; color: white; }

        #boss-ui {
            position: absolute;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            display: none; text-align: center;
            z-index: 10;
        }
        #boss-hp-bar { width: 600px; height: 20px; background: rgba(0,0,0,0.8); border: 2px solid #ff0044; border-radius: 10px; box-shadow: 0 0 30px rgba(255,0,0,0.4); overflow: hidden; }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(to right, #990000, #ff0044, #ff6666); transition: width 0.1s; }
        
        #chapter-announcement {
            position: absolute;
            top: 40%; width: 100%;
            text-align: center; color: #fff;
            font-size: 50px; font-weight: 900;
            letter-spacing: 15px;
            opacity: 0; pointer-events: none;
            text-shadow: 0 0 30px #fff, 0 0 60px #ff0044;
            z-index: 20;
            transition: opacity 1s, transform 1s;
            transform: scale(0.8);
        }

        #msg {
            position: absolute;
            bottom: 180px; width: 100%;
            text-align: center; color: #fff;
            font-size: 24px; font-weight: bold;
            transition: opacity 0.5s; pointer-events: none;
            text-shadow: 0 0 15px #ff0000;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="current-chapter-name" style="font-size: 14px; color: #00ffcc; margin-bottom: 5px; letter-spacing: 1px;">區域: 幽暗森林</div>
        <div style="font-size: 18px; font-weight: bold; letter-spacing: 1px;">狀態監測</div>
        <div id="hp-bar-container">
            <div id="hp-bar"><div id="hp-fill"></div><div id="hp-text">100 / 100</div></div>
        </div>
        <div id="abilities" style="margin-top: 20px; font-size: 13px;">
            <div id="tag-doublejump" style="color: rgba(255,255,255,0.2);">[ 二段跳躍 ]</div>
            <div id="tag-dash" style="color: rgba(255,255,255,0.2);">[ 瞬間衝刺 ]</div>
            <div id="tag-parry" style="color: #ffcc00;">[ 戰鬥格擋 - Q / RMB ]</div>
            <div id="tag-heal" style="color: #00ff88;">[ 能量回溯 - E ]</div>
        </div>
    </div>

    <div id="boss-ui">
        <div id="boss-name" style="color: #ff0044; font-weight: 900; margin-bottom: 8px; font-size: 22px; letter-spacing: 8px; text-shadow: 0 0 15px #ff0044;">古代守衛者：厄瑞玻斯</div>
        <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
    </div>

    <div id="tutorial-overlay">
        <div class="key-box"><div id="key-W" class="key">W</div><div class="key-label">JUMP</div></div>
        <div class="key-box"><div id="key-Shift" class="key">SHIFT</div><div class="key-label">DASH</div></div>
        <div class="key-box"><div id="key-Q" class="key">Q</div><div class="key-label">PARRY</div></div>
        <div class="key-box"><div id="key-E" class="key">E</div><div class="key-label">HEAL</div></div>
    </div>

    <div id="chapter-announcement">第二章：厄瑞玻斯聖殿</div>
    <div id="msg"></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const GRAVITY = 0.6;
        const FRICTION = 0.85;
        let WORLD_WIDTH = 3500; 
        let WORLD_HEIGHT = 1500;

        let gameActive = true;
        let currentChapter = 1;
        let screenShake = 0;
        let hitStop = 0; // 畫面凍結幀數
        
        const player = {
            x: 100, y: 1300, vx: 0, vy: 0,
            width: 30, height: 45,
            jumpForce: 13, isGrounded: false, canDoubleJump: false,
            isOnWall: false, wallDir: 0, 
            hasDoubleJumpSkill: false, hasDashSkill: false,
            dashCooldown: 0, hp: 100, maxHp: 100, color: '#00d4ff',
            ghosts: [], 
            isDashing: false,
            // 戰鬥新狀態
            isParrying: false, parryTimer: 0, 
            isHealing: false, healTimer: 0
        };

        const boss = {
            x: 1200, y: 1100,
            width: 140, height: 140,
            hp: 800, maxHp: 800,
            active: false,
            state: 'idle',
            timer: 0,
            color: '#ff0044',
            powerLevel: 0, 
            recoveryDuration: 100 
        };

        const camera = { x: 0, y: 0 };
        const chapter1Platforms = [
            { x: 0, y: 1400, w: 1000, h: 100 },
            { x: 450, y: 1250, w: 40, h: 40, type: 'skill_jump', color: '#00ffcc' },
            { x: 800, y: 1150, w: 40, h: 40, type: 'skill_dash', color: '#ff00ff' },
            { x: 650, y: 1200, w: 150, h: 20 },
            { x: 1100, y: 1250, w: 200, h: 20 },
            { x: 1400, y: 1100, w: 100, h: 20 },
            { x: 1600, y: 950, w: 80, h: 20 }, 
            { x: 1850, y: 800, w: 30, h: 700 }, 
            { x: 2100, y: 650, w: 150, h: 20 },
            { x: 2400, y: 550, w: 30, h: 1000 },
            { x: 2600, y: 1400, w: 900, h: 100 }
        ];

        const chapter2Platforms = [
            { x: 0, y: 1350, w: 2000, h: 200 },
            { x: 300, y: 1150, w: 200, h: 20 },
            { x: 1500, y: 1150, w: 200, h: 20 },
            { x: 900, y: 1000, w: 200, h: 20 },
            { x: 600, y: 850, w: 150, h: 20 },
            { x: 1250, y: 850, w: 150, h: 20 },
            { x: 900, y: 700, w: 200, h: 20 },
            { x: -50, y: 0, w: 50, h: 1500 },
            { x: 2000, y: 0, w: 50, h: 1500 }
        ];

        let platforms = [...chapter1Platforms];
        let bullets = [];
        let enemyBullets = []; 
        let particles = [];
        let bloodMists = []; 
        let minions = [];    
        let bgParticles = []; 
        const keys = {};

        // 初始化環境粒子
        for(let i=0; i<60; i++) {
            bgParticles.push({
                x: Math.random() * 3500, y: Math.random() * 1500,
                vx: (Math.random() - 0.5) * 0.8, vy: 0.3 + Math.random() * 0.7,
                size: 1 + Math.random() * 2, color: '#2d4d2d'
            });
        }

        window.addEventListener('keydown', e => { 
            keys[e.code] = true; 
            updateKeyVisuals(e.code, true);
            if (e.code === 'KeyQ') startParry();
            if (e.code === 'KeyE') player.isHealing = true;
        });
        window.addEventListener('keyup', e => { 
            keys[e.code] = false; 
            updateKeyVisuals(e.code, false);
            if (e.code === 'KeyQ') stopParry();
            if (e.code === 'KeyE') player.isHealing = false;
        });
        window.addEventListener('mousedown', e => {
            if (e.button === 0) shoot(e);
            if (e.button === 2) { startParry(); updateKeyVisuals('KeyQ', true); }
        });
        window.addEventListener('mouseup', e => {
            if (e.button === 2) { stopParry(); updateKeyVisuals('KeyQ', false); }
        });
        window.addEventListener('contextmenu', e => e.preventDefault());

        function startParry() { if (!player.isParrying) { player.isParrying = true; player.parryTimer = 0; } }
        function stopParry() { player.isParrying = false; }

        function updateKeyVisuals(code, isActive) {
            let id = "";
            if (code === 'KeyW' || code === 'Space') id = "key-W";
            if (code === 'ShiftLeft') id = "key-Shift";
            if (code === 'KeyQ') id = "key-Q";
            if (code === 'KeyE') id = "key-E";
            const el = document.getElementById(id);
            if (el) isActive ? el.classList.add('active') : el.classList.remove('active');
        }

        function showMsg(text) {
            const m = document.getElementById('msg');
            m.innerText = text; m.style.opacity = 1;
            setTimeout(() => { m.style.opacity = 0; }, 3000);
        }

        function switchChapter() {
            currentChapter = 2;
            WORLD_WIDTH = 2000;
            platforms = [...chapter2Platforms];
            player.x = 100; player.y = 1200;
            screenShake = 30;
            document.getElementById('current-chapter-name').innerText = "區域: 厄瑞玻斯聖殿";
            document.getElementById('current-chapter-name').style.color = "#ff4444";
            const ann = document.getElementById('chapter-announcement');
            ann.style.opacity = 1; ann.style.transform = "scale(1)";
            setTimeout(() => { ann.style.opacity = 0; ann.style.transform = "scale(0.8)"; }, 3000);
            bgParticles.forEach(p => { p.color = '#ff4400'; p.vy = - (0.8 + Math.random()); });
            boss.active = true; boss.x = 1000; boss.y = 1100;
            document.getElementById('boss-ui').style.display = 'block';
        }

        function shoot(e) {
            if (!gameActive || player.isParrying || player.isHealing) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const angle = Math.atan2(mouseY - (player.y - camera.y + player.height/2), mouseX - (player.x - camera.x + player.width/2));
            bullets.push({ x: player.x + player.width/2, y: player.y + player.height/2, vx: Math.cos(angle) * 16, vy: Math.sin(angle) * 16, life: 100 });
        }

        function handlePlayerDamage(dmg, isProjectile = false, projObj = null) {
            if (player.isParrying) {
                if (player.parryTimer < 12) { // 完美格擋窗口
                    createParticles(player.x + 15, player.y + 22, '#ffcc00', 30);
                    screenShake = 15; hitStop = 8;
                    showMsg("PERFECT PARRY!");
                    if (isProjectile && projObj) {
                        projObj.vx *= -1.5; projObj.vy *= -1.5; projObj.color = '#00ffff'; // 反彈子彈
                        return false; 
                    }
                    return false;
                } else { // 普通格擋 (減傷 70%)
                    player.hp -= dmg * 0.3;
                    createParticles(player.x + 15, player.y + 22, '#ffffff', 5);
                    screenShake = 5;
                    return true;
                }
            }
            player.hp -= dmg;
            screenShake = 15;
            createParticles(player.x + 15, player.y + 22, '#ff0000', 15);
            return true;
        }

        function updateBoss() {
            if (!boss.active || boss.hp <= 0) return;
            boss.timer++;
            if (boss.state === 'idle' && boss.timer > 70) {
                const states = ['mirage', 'bloodMist', 'power', 'starRain', 'nova'];
                boss.state = states[Math.floor(Math.random() * states.length)];
                boss.timer = 0;
            }
            // (Boss 邏輯保持原樣，但在 Nova 等攻擊中會調用 handlePlayerDamage)
            switch (boss.state) {
                case 'recovery':
                    boss.color = '#1a0005';
                    if (boss.timer > boss.recoveryDuration) { boss.state = 'idle'; boss.timer = 0; }
                    break;
                case 'starRain':
                    if (boss.timer % 8 === 0 && boss.timer < 100) {
                        const startX = Math.random() * WORLD_WIDTH;
                        enemyBullets.push({ type: 'meteor', x: startX, y: -100, vx: (player.x - startX) * 0.005, vy: 10, radius: 30, life: 300, color: '#bc13fe', trail: [] });
                    }
                    if (boss.timer > 160) { boss.state = 'recovery'; boss.timer = 0; }
                    break;
                case 'mirage':
                    if (boss.timer % 40 === 0) {
                        boss.x = player.x + (Math.random() > 0.5 ? 180 : -180); boss.y = player.y - 40;
                        const dist = Math.sqrt(Math.pow(player.x - (boss.x + 70), 2) + Math.pow(player.y - (boss.y + 70), 2));
                        if (dist < 180) handlePlayerDamage(15);
                        if (++boss.mirageCount >= 4) { boss.state = 'recovery'; boss.timer = 0; boss.mirageCount = 0; }
                    }
                    break;
                case 'nova':
                    if (boss.timer === 40) {
                        for (let i = 0; i < 24; i++) {
                            const a = (i / 24) * Math.PI * 2;
                            enemyBullets.push({ x: boss.x + 70, y: boss.y + 70, vx: Math.cos(a) * 10, vy: Math.sin(a) * 10, life: 120, color: '#ff0000' });
                        }
                    }
                    if (boss.timer > 90) boss.state = 'recovery';
                    break;
                case 'idle':
                    boss.y = 900 + Math.sin(Date.now() / 400) * 50;
                    break;
            }
        }

        function update() {
            if (!gameActive) return;
            if (hitStop > 0) { hitStop--; return; }

            if (screenShake > 0) screenShake *= 0.9;
            if (player.dashCooldown > 0) player.dashCooldown--;
            
            // 格擋計時
            if (player.isParrying) player.parryTimer++;

            // 回血邏輯
            if (player.isHealing && player.hp < player.maxHp) {
                player.healTimer++;
                if (player.healTimer % 10 === 0) {
                    player.hp = Math.min(player.maxHp, player.hp + 1.5);
                    createParticles(player.x + 15, player.y + 22, '#00ff88', 2);
                }
                player.vx *= 0.5; // 回血時減速
            } else {
                player.healTimer = 0;
            }

            // 殘影
            if (Math.abs(player.vx) > 10 || player.isDashing || player.isParrying) {
                player.ghosts.push({ x: player.x, y: player.y, alpha: 0.5, color: player.isParrying ? '#ffcc00' : player.color });
                if (player.ghosts.length > 10) player.ghosts.shift();
            } else if (player.ghosts.length > 0) player.ghosts.shift();

            // 環境粒子
            bgParticles.forEach(p => {
                p.x += p.vx; p.y += p.vy;
                if (p.y > WORLD_HEIGHT) p.y = -10; if (p.y < -10) p.y = WORLD_HEIGHT;
            });

            // 移動 (格擋或回血時限制移動)
            if (!player.isHealing) {
                if (keys['KeyA']) player.vx -= 0.8;
                if (keys['KeyD']) player.vx += 0.8;
            }
            player.vx *= FRICTION;
            player.vy += (player.isOnWall && player.vy > 0) ? GRAVITY * 0.3 : GRAVITY;

            if ((keys['KeyW'] || keys['Space']) && !player.isHealing) {
                if (player.isGrounded) { player.vy = -player.jumpForce; player.isGrounded = false; keys['KeyW'] = keys['Space'] = false; }
                else if (player.hasDoubleJumpSkill && player.canDoubleJump) { player.vy = -player.jumpForce * 0.8; player.canDoubleJump = false; keys['KeyW'] = keys['Space'] = false; }
            }

            if (keys['ShiftLeft'] && player.hasDashSkill && player.dashCooldown <= 0 && !player.isHealing) { 
                player.vx = (player.vx >= 0 ? 1 : -1) * 28; player.dashCooldown = 50; player.isDashing = true;
                setTimeout(() => player.isDashing = false, 200);
            }

            player.x += player.vx; player.y += player.vy;
            player.isGrounded = false; let touchingWall = false;

            platforms.forEach((p, i) => {
                if (player.x < p.x + p.w && player.x + player.width > p.x && player.y < p.y + p.h && player.y + player.height > p.y) {
                    if (p.type) {
                        if (p.type === 'skill_jump') { player.hasDoubleJumpSkill = true; document.getElementById('tag-doublejump').style.color = '#00ffcc'; }
                        else if (p.type === 'skill_dash') { player.hasDashSkill = true; document.getElementById('tag-dash').style.color = '#ff00ff'; }
                        platforms.splice(i, 1); return;
                    }
                    if (player.vy > 0 && player.y + player.height - player.vy <= p.y) { player.y = p.y - player.height; player.vy = 0; player.isGrounded = true; player.canDoubleJump = true; } 
                    else if (player.x + player.width - player.vx <= p.x) { player.x = p.x - player.width; touchingWall = true; }
                    else if (player.x - player.vx >= p.x + p.w) { player.x = p.x + p.w; touchingWall = true; }
                }
            });
            player.isOnWall = touchingWall;

            if (currentChapter === 1 && player.x > 3400) switchChapter();
            updateBoss();
            
            enemyBullets.forEach((eb, ei) => {
                eb.x += eb.vx; eb.y += eb.vy; eb.life--;
                const dist = Math.sqrt(Math.pow(player.x + 15 - eb.x, 2) + Math.pow(player.y + 22 - eb.y, 2));
                if (dist < (eb.radius || 10) + 15) {
                    if (handlePlayerDamage(10, true, eb)) { enemyBullets.splice(ei, 1); }
                }
                if (eb.life <= 0 || eb.y > 1400) enemyBullets.splice(ei, 1);
            });

            bullets.forEach((b, bi) => {
                b.x += b.vx; b.y += b.vy; b.life--;
                if (boss.active && b.x > boss.x && b.x < boss.x + boss.width && b.y > boss.y && b.y < boss.y + boss.height) {
                    boss.hp -= (boss.state === 'recovery' ? 5 : 2); 
                    createParticles(b.x, b.y, '#ffffff', 5); bullets.splice(bi, 1);
                    if (boss.hp <= 0) { gameActive = false; screenShake = 50; showMsg("厄瑞玻斯已被擊敗！"); }
                }
                if (b.life <= 0) bullets.splice(bi, 1);
            });

            camera.x += (player.x - canvas.width / 2 - camera.x) * 0.1;
            camera.y += (player.y - canvas.height / 2 - camera.y) * 0.1;
            camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - canvas.width));
            camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - canvas.height));

            document.getElementById('hp-fill').style.width = (player.hp / player.maxHp * 100) + '%';
            document.getElementById('hp-text').innerText = `${Math.ceil(player.hp)} / ${player.maxHp}`;
            document.getElementById('boss-hp-fill').style.width = (boss.hp / boss.maxHp * 100) + '%';
            particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= 0.02; if (p.life <= 0) particles.splice(i, 1); });
            
            if (player.hp <= 0 && gameActive) { gameActive = false; showMsg("任務失敗..."); screenShake = 40; }
        }

        function createParticles(x, y, color, count = 8) {
            for(let i=0; i<count; i++) particles.push({ x, y, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, life: 1, color });
        }

        function draw() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            ctx.fillStyle = currentChapter === 1 ? '#050a05' : '#0a0505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            if (screenShake > 0) ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);

            bgParticles.forEach(p => {
                ctx.fillStyle = p.color; ctx.globalAlpha = 0.2;
                ctx.beginPath(); ctx.arc(p.x - camera.x, p.y - camera.y, p.size, 0, Math.PI*2); ctx.fill();
            });
            ctx.globalAlpha = 1;

            ctx.translate(-camera.x, -camera.y);

            platforms.forEach(p => {
                ctx.fillStyle = p.type ? p.color : (currentChapter === 1 ? '#1a2e1a' : '#331a1a');
                ctx.shadowBlur = p.type ? 20 : 0; ctx.shadowColor = p.color;
                ctx.fillRect(p.x, p.y, p.w, p.h);
            });

            enemyBullets.forEach(eb => {
                ctx.fillStyle = eb.color || '#f00'; ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath(); ctx.arc(eb.x, eb.y, eb.radius || 7, 0, Math.PI*2); ctx.fill();
            });

            if (boss.active && boss.hp > 0) {
                ctx.fillStyle = boss.color; ctx.shadowBlur = 40; ctx.shadowColor = boss.color;
                ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
            }

            // 玩家殘影
            player.ghosts.forEach((g, i) => {
                ctx.globalAlpha = g.alpha * (i / player.ghosts.length);
                ctx.fillStyle = g.color;
                ctx.fillRect(g.x, g.y, player.width, player.height);
            });
            ctx.globalAlpha = 1;

            // 繪製格擋護盾
            if (player.isParrying) {
                ctx.strokeStyle = player.parryTimer < 12 ? '#ffcc00' : '#ffffff';
                ctx.lineWidth = 4; ctx.beginPath();
                ctx.arc(player.x + 15, player.y + 22, 40, 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = player.parryTimer < 12 ? 'rgba(255, 204, 0, 0.2)' : 'rgba(255, 255, 255, 0.1)';
                ctx.fill();
            }

            // 玩家本體
            ctx.shadowBlur = 20; ctx.shadowColor = player.color; ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            bullets.forEach(b => { ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI*2); ctx.fill(); });
            particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); });

            ctx.restore();
            if (gameActive) update();
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>
