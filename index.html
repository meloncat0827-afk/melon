<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Metroidvania - Parkour & Boss</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: white; pointer-events: none;
            text-shadow: 2px 2px 2px #000;
        }

        #tutorial-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            pointer-events: none;
        }

        .key-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            min-width: 50px;
        }

        .key {
            width: 40px;
            height: 40px;
            border: 2px solid #fff;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            transition: all 0.1s;
        }

        .key.active {
            background: #00d4ff;
            color: #000;
            transform: scale(0.9);
            box-shadow: 0 0 15px #00d4ff;
        }

        .key-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #aaa;
        }

        #hp-bar { width: 200px; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; margin-top: 5px; }
        #hp-fill { width: 100%; height: 100%; background: #ff4d4d; border-radius: 5px; transition: width 0.3s; }
        
        #boss-ui {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            display: none;
            text-align: center;
        }
        #boss-hp-bar { width: 400px; height: 15px; background: rgba(0,0,0,0.5); border: 1px solid #ff0000; border-radius: 3px; }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(to right, #660000, #ff0000); }

        #msg {
            position: absolute;
            bottom: 100px; width: 100%;
            text-align: center; color: #fff;
            font-size: 24px; font-weight: bold;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-size: 20px; font-weight: bold;">玩家生命值</div>
        <div id="hp-bar"><div id="hp-fill"></div></div>
        <div id="abilities" style="margin-top: 15px;">
            <div id="tag-doublejump" style="color: rgba(255,255,255,0.3);">● 二段跳</div>
            <div id="tag-dash" style="color: rgba(255,255,255,0.3);">● 衝刺</div>
        </div>
    </div>

    <div id="boss-ui">
        <div style="color: #ff0000; font-weight: bold; margin-bottom: 5px;">最終守衛者的核心</div>
        <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
    </div>

    <div id="tutorial-overlay">
        <div class="key-box"><div id="key-W" class="key">W</div><div class="key-label">跳躍</div></div>
        <div class="key-box"><div id="key-A" class="key">A</div><div class="key-label">向左</div></div>
        <div class="key-box"><div id="key-D" class="key">D</div><div class="key-label">向右</div></div>
        <div class="key-box"><div id="key-Shift" class="key" style="width: 70px;">SHIFT</div><div class="key-label">衝刺</div></div>
    </div>

    <div id="msg"></div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const GRAVITY = 0.6;
        const FRICTION = 0.85;
        const WORLD_WIDTH = 5000; // 擴大地圖寬度
        const WORLD_HEIGHT = 1500;

        let gameActive = true;
        
        const player = {
            x: 100, y: 1300,
            vx: 0, vy: 0,
            width: 30, height: 45,
            speed: 5,
            jumpForce: 13,
            isGrounded: false,
            canDoubleJump: false,
            isOnWall: false,
            wallDir: 0, 
            hasDoubleJumpSkill: false,
            hasDashSkill: false,
            dashCooldown: 0,
            hp: 100,
            color: '#00d4ff'
        };

        const boss = {
            x: 4300, y: 1100,
            width: 120, height: 120,
            hp: 100, maxHp: 100,
            active: false,
            shootTimer: 0,
            color: '#ff0044'
        };

        const camera = { x: 0, y: 0 };

        const platforms = [
            // 起點區
            { x: 0, y: 1400, w: 1000, h: 100 },
            { x: 450, y: 1250, w: 40, h: 40, type: 'skill_jump', label: '二段跳核心', color: '#00ffcc' },
            { x: 700, y: 1100, w: 40, h: 40, type: 'skill_dash', label: '衝刺模組', color: '#ff00ff' },
            { x: 650, y: 1200, w: 150, h: 20 },
            
            // 跑酷銜接區
            { x: 1100, y: 1200, w: 100, h: 20 },
            { x: 1350, y: 1100, w: 80, h: 20 },
            { x: 1600, y: 950, w: 60, h: 20 }, // 小跳台
            
            // 牆跳跑酷區 (需要二段跳)
            { x: 1800, y: 700, w: 30, h: 700 }, // 牆1
            { x: 2050, y: 500, w: 30, h: 700 }, // 牆2
            { x: 2300, y: 400, w: 30, h: 600 }, // 牆3
            
            // 長距離衝刺區
            { x: 2450, y: 450, w: 200, h: 20 },
            { x: 3000, y: 550, w: 150, h: 20 },
            { x: 3400, y: 750, w: 100, h: 20 },
            
            // Boss 戰場入口
            { x: 3800, y: 1300, w: 1200, h: 200 }
        ];

        let bullets = [];
        let enemyBullets = [];
        let particles = [];
        const keys = {};

        window.addEventListener('keydown', e => { keys[e.code] = true; updateKeyVisuals(e.code, true); });
        window.addEventListener('keyup', e => { keys[e.code] = false; updateKeyVisuals(e.code, false); });
        window.addEventListener('mousedown', (e) => shoot(e));

        function updateKeyVisuals(code, isActive) {
            let id = "";
            if (code === 'KeyW' || code === 'ArrowUp' || code === 'Space') id = "key-W";
            if (code === 'KeyA' || code === 'ArrowLeft') id = "key-A";
            if (code === 'KeyD' || code === 'ArrowRight') id = "key-D";
            if (code === 'ShiftLeft' || code === 'ShiftRight') id = "key-Shift";
            const el = document.getElementById(id);
            if (el) isActive ? el.classList.add('active') : el.classList.remove('active');
        }

        function showMsg(text) {
            const m = document.getElementById('msg');
            m.innerText = text; m.style.opacity = 1;
            setTimeout(() => { m.style.opacity = 0; }, 3000);
        }

        function shoot(e) {
            if (!gameActive) return;
            const angle = Math.atan2(
                (e.clientY - (player.y - camera.y + player.height/2)),
                (e.clientX - (player.x - camera.x + player.width/2))
            );
            bullets.push({ x: player.x + player.width/2, y: player.y + player.height/2, vx: Math.cos(angle) * 15, vy: Math.sin(angle) * 15, life: 100 });
        }

        function bossShoot() {
            if (boss.hp <= 0) return;
            // 擴散彈
            for (let i = -1; i <= 1; i++) {
                const angle = Math.atan2(player.y - boss.y, player.x - boss.x) + (i * 0.2);
                enemyBullets.push({ x: boss.x + boss.width/2, y: boss.y + boss.height/2, vx: Math.cos(angle) * 7, vy: Math.sin(angle) * 7, life: 200 });
            }
        }

        function update() {
            if (!gameActive) return;

            // 玩家物理
            if (keys['KeyA'] || keys['ArrowLeft']) player.vx -= 0.8;
            if (keys['KeyD'] || keys['ArrowRight']) player.vx += 0.8;
            player.vx *= FRICTION;
            let currentGravity = GRAVITY;
            if (player.isOnWall && player.vy > 0) currentGravity = GRAVITY * 0.3;
            player.vy += currentGravity;

            if (keys['KeyW'] || keys['Space'] || keys['ArrowUp']) {
                if (player.isGrounded) { player.vy = -player.jumpForce; player.isGrounded = false; keys['KeyW'] = keys['Space'] = keys['ArrowUp'] = false; } 
                else if (player.isOnWall) { player.vy = -player.jumpForce * 0.9; player.vx = -player.wallDir * 12; player.isOnWall = false; keys['KeyW'] = keys['Space'] = keys['ArrowUp'] = false; }
                else if (player.hasDoubleJumpSkill && player.canDoubleJump) { player.vy = -player.jumpForce * 0.8; player.canDoubleJump = false; keys['KeyW'] = keys['Space'] = keys['ArrowUp'] = false; createParticles(player.x + 15, player.y + 40, '#fff'); }
            }

            if (keys['ShiftLeft'] && player.hasDashSkill && player.dashCooldown <= 0) {
                player.vx = (player.vx >= 0 ? 1 : -1) * 25;
                player.dashCooldown = 60;
                createParticles(player.x, player.y, '#ff00ff');
            }
            if (player.dashCooldown > 0) player.dashCooldown--;

            player.x += player.vx; player.y += player.vy;
            player.isGrounded = false;
            let touchingWall = false;
            let wallDirection = 0;

            // 平台與核心碰撞
            for (let i = platforms.length - 1; i >= 0; i--) {
                const p = platforms[i];
                if (player.x < p.x + p.w && player.x + player.width > p.x && player.y < p.y + p.h && player.y + player.height > p.y) {
                    if (p.type) {
                        if (p.type === 'skill_jump') { player.hasDoubleJumpSkill = true; document.getElementById('tag-doublejump').style.color = '#00ffcc'; showMsg("獲得能力：二段跳！"); }
                        else if (p.type === 'skill_dash') { player.hasDashSkill = true; document.getElementById('tag-dash').style.color = '#ff00ff'; showMsg("獲得能力：衝刺！"); }
                        createParticles(p.x + p.w/2, p.y + p.h/2, p.color, 15); platforms.splice(i, 1); continue;
                    }
                    if (player.vy > 0 && player.y + player.height - player.vy <= p.y) { player.y = p.y - player.height; player.vy = 0; player.isGrounded = true; player.canDoubleJump = true; } 
                    else if (player.x + player.width - player.vx <= p.x) { player.x = p.x - player.width; player.vx = 0; if (!player.isGrounded) { touchingWall = true; wallDirection = 1; } }
                    else if (player.x - player.vx >= p.x + p.w) { player.x = p.x + p.w; player.vx = 0; if (!player.isGrounded) { touchingWall = true; wallDirection = -1; } }
                    else { player.y = p.y + p.h; player.vy = 0; }
                }
            }
            player.isOnWall = touchingWall; player.wallDir = wallDirection;

            // Boss 啟動與邏輯
            if (player.x > 3800) {
                boss.active = true;
                document.getElementById('boss-ui').style.display = 'block';
            }
            if (boss.active && boss.hp > 0) {
                boss.shootTimer++;
                if (boss.shootTimer > 60) { bossShoot(); boss.shootTimer = 0; }
            }

            // 子彈碰撞
            bullets.forEach((b, bi) => {
                b.x += b.vx; b.y += b.vy; b.life--;
                if (boss.active && b.x > boss.x && b.x < boss.x + boss.width && b.y > boss.y && b.y < boss.y + boss.height) {
                    boss.hp -= 2; createParticles(b.x, b.y, '#ff0044'); bullets.splice(bi, 1);
                    if (boss.hp <= 0) { showMsg("你成功守護了世界！勝利！"); gameActive = false; }
                }
                if (b.life <= 0) bullets.splice(bi, 1);
            });

            // 敵方子彈碰撞
            enemyBullets.forEach((eb, ei) => {
                eb.x += eb.vx; eb.y += eb.vy; eb.life--;
                if (eb.x > player.x && eb.x < player.x + player.width && eb.y > player.y && eb.y < player.y + player.height) {
                    player.hp -= 10; createParticles(eb.x, eb.y, '#ff0000'); enemyBullets.splice(ei, 1);
                    if (player.hp <= 0) { showMsg("你被核心守衛擊敗了..."); gameActive = false; }
                }
                if (eb.life <= 0) enemyBullets.splice(ei, 1);
            });

            // 世界邊界
            if (player.x < 0) player.x = 0;
            if (player.x > WORLD_WIDTH - player.width) player.x = WORLD_WIDTH - player.width;
            if (player.y > WORLD_HEIGHT) { player.x = 100; player.y = 1300; player.hp = Math.max(0, player.hp - 10); }

            // 攝像機
            camera.x += (player.x - canvas.width / 2 - camera.x) * 0.1;
            camera.y += (player.y - canvas.height / 2 - camera.y) * 0.1;
            camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - canvas.width));
            camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - canvas.height));

            // UI 更新
            document.getElementById('hp-fill').style.width = player.hp + '%';
            document.getElementById('boss-hp-fill').style.width = (boss.hp / boss.maxHp * 100) + '%';
            particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= 0.02; if (p.life <= 0) particles.splice(i, 1); });
        }

        function createParticles(x, y, color, count = 8) {
            for(let i=0; i<count; i++) { particles.push({ x, y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 1, color }); }
        }

        function draw() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            ctx.fillStyle = '#0a0a14'; ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save(); ctx.translate(-camera.x, -camera.y);

            // 繪製背景裝飾 (遠景)
            ctx.fillStyle = '#151525';
            for(let i=0; i<WORLD_WIDTH; i+=600) ctx.fillRect(i, 200, 300, 1300);

            // 繪製平台
            platforms.forEach(p => {
                if (p.type) {
                    ctx.fillStyle = p.color; ctx.shadowBlur = 25; ctx.shadowColor = p.color;
                    const offset = Math.sin(Date.now() / 200) * 5; ctx.fillRect(p.x, p.y + offset, p.w, p.h);
                    ctx.font = "bold 12px Arial"; ctx.fillStyle = "#fff"; ctx.fillText(p.label, p.x - 10, p.y - 10 + offset);
                } else {
                    ctx.shadowBlur = 0; ctx.fillStyle = '#222'; ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = '#444'; ctx.strokeRect(p.x, p.y, p.w, p.h);
                }
            });

            // 繪製 Boss
            if (boss.active && boss.hp > 0) {
                ctx.fillStyle = boss.color; ctx.shadowBlur = 30; ctx.shadowColor = '#ff0044';
                const bOffset = Math.sin(Date.now() / 150) * 10;
                ctx.fillRect(boss.x, boss.y + bOffset, boss.width, boss.height);
                // Boss 眼睛
                ctx.fillStyle = '#000';
                ctx.fillRect(boss.x + 30, boss.y + 40 + bOffset, 20, 20);
                ctx.fillRect(boss.x + 70, boss.y + 40 + bOffset, 20, 20);
            }

            // 繪製玩家
            ctx.shadowBlur = 15; ctx.shadowColor = player.color; ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            if (player.isOnWall) { ctx.fillStyle = '#fff'; ctx.fillRect(player.x + (player.wallDir === 1 ? player.width : -5), player.y, 5, player.height); }

            // 子彈
            ctx.shadowBlur = 0; ctx.fillStyle = '#ffff00';
            bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill(); });
            ctx.fillStyle = '#ff0000';
            enemyBullets.forEach(eb => { ctx.beginPath(); ctx.arc(eb.x, eb.y, 6, 0, Math.PI*2); ctx.fill(); });
            
            // 粒子
            particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill(); });

            ctx.restore();
            update();
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>
